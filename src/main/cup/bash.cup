package Parsing;

import ru.hse.fmcs.Parsing.ASTNode.*;

class Parser;

terminal AssignmentWord, Word, StringLiteral;

nonterminal Assignment, AssignmentsList;
nonterminal Argument, ArgumentsList;
nonterminal Function, FunctionCall;
nonterminal EnvSetup, EnvFunctionCall;
nonterminal SingleCommand;

start with SingleCommand;

SingleCommand ::= EnvSetup:env {: RESULT = (ASTNode) env; :}
                | EnvFunctionCall:envFunc {: RESULT = (ASTNode) envFunc; :};

EnvSetup ::= AssignmentsList:assign {: RESULT = new ASTNodeEnvSetup((ASTNodeAssignmentsList) assign); :};
EnvFunctionCall ::= AssignmentsList:assign FunctionCall:func {: RESULT = new ASTNodeEnvFunctionCall((ASTNodeAssignmentsList) assign, (ASTNodeFunctionCall) func); :};

Assignment ::= AssignmentWord:assign {:
             String headString = (String) assign;
             int asgnIdx = headString.indexOf('=');
             String name = headString.substring(0, asgnIdx);
             String value = headString.substring(asgnIdx + 1);
             RESULT = new ASTNodeAssignment(name, value);
            :};
AssignmentsList ::= Assignment:head AssignmentsList:tail {:
                RESULT = new ASTNodeAssignmentsList((ASTNodeAssignment) head, (ASTNodeAssignmentsList) tail);
              :}
              | {: RESULT = null; :}
              ;

Function ::= Word:name {: RESULT = name; :}
           | StringLiteral:name {: RESULT = name; :} ;
FunctionCall ::= Function:func ArgumentsList:args {: RESULT = new ASTNodeFunctionCall((String) func, (ASTNodeArgumentsList) args); :};

Argument ::= Word:name {: RESULT = new ASTNodeArgument((String) name); :}
           | StringLiteral:name {: RESULT = new ASTNodeArgument((String) name); :};
ArgumentsList ::= Argument:head ArgumentsList:tail {: RESULT = new ASTNodeArgumentsList((ASTNodeArgument) head, (ASTNodeArgumentsList) tail); :}
                | {: RESULT = null; :}
                ;


